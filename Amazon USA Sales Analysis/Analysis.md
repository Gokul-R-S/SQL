# Amazon Sales Analysis

A comprehensive collection of SQL queries solving real-world business problems in e-commerce analytics, customer retention, product performance, and operational efficiency.

---

## Table of Contents

1. Customer Retention Analysis
2. Quarterly Category Performance Matrix
3. Revenue by Category
4. Least-Selling Categories by State
5. Product Returns Analysis
6. Revenue Decline Analysis
7. Inactive Sellers Report
8. Inventory Optimization for High-Margin Products
9. Underperforming Sellers Analysis
10. Monthly Seller Performance Report Function

---

## 1. Customer Retention Analysis

### Business Problem
The marketing team wants to launch a targeted retention campaign for high-value customers showing signs of churn. Identify customers who have spent over $5,000 lifetime but haven't made a purchase in the last 90 days.

### Objective
Find customers worth retaining (based on historical value) before they churn completely, enabling the marketing team to proactively reach out with personalized offers.

### Expected Output
- Customer details (name, location)
- Total lifetime value
- Days since last purchase
- Number of previous orders
- Last order date
- Churn risk level

### Solution

```sql
WITH customer_spending AS (
    SELECT
        c.customer_id,
        c.first_name || ' ' || c.last_name AS customer_name,
        c.state,
        c.address,
        COUNT(o.order_id) AS total_orders,
        SUM(oi.total_sale) AS lifetime_value,
        MAX(o.order_date) AS last_order_date,
        CURRENT_DATE - MAX(o.order_date) AS days_since_last_order
    FROM customers c
    JOIN orders o USING(customer_id)
    JOIN order_items oi USING(order_id)
    WHERE o.order_status != 'Cancelled'
    GROUP BY 
        c.customer_id, 
        c.first_name, 
        c.last_name, 
        c.state, 
        c.address
)
SELECT
    customer_name,
    state,
    total_orders,
    ROUND(lifetime_value, 2) AS lifetime_value,
    last_order_date,
    days_since_last_order,
    CASE
        WHEN days_since_last_order BETWEEN 90 AND 120 THEN 'Medium Risk'
        WHEN days_since_last_order > 120 THEN 'High Risk'
    END AS churn_risk_level
FROM customer_spending
WHERE lifetime_value > 5000
    AND days_since_last_order >= 90
ORDER BY 
    lifetime_value DESC,
    days_since_last_order DESC;
```

---

## 2. Quarterly Category Performance Matrix

### Business Problem
The executive team needs a quarterly revenue dashboard showing how each product category performs across different quarters. They want to see trends at a glance—which categories are growing, declining, or seasonal—in a spreadsheet-style pivot table format.

### Objective
Create a pivot table showing total revenue for each category across quarters (Q1 2023 through Q1 2024), making it easy to spot seasonal patterns and growth trends.

### Expected Output
A matrix where:
- **Rows** = Product categories
- **Columns** = Quarters (2023-Q1, 2023-Q2, 2023-Q3, 2023-Q4, 2024-Q1)
- **Values** = Total revenue (in millions)

### Solution

```sql
SELECT 
    category_name,
    ROUND("2023-Q1" / 1000000, 2) || 'M' AS "2023-Q1",
    ROUND("2023-Q2" / 1000000, 2) || 'M' AS "2023-Q2",
    ROUND("2023-Q3" / 1000000, 2) || 'M' AS "2023-Q3",
    ROUND("2023-Q4" / 1000000, 2) || 'M' AS "2023-Q4",
    ROUND("2024-Q1" / 1000000, 2) || 'M' AS "2024-Q1"
FROM CROSSTAB(
    $$ 
    SELECT
        c.category_name,
        TO_CHAR(o.order_date, 'YYYY-"Q"Q') AS quarter,
        ROUND(SUM(oi.quantity * oi.price_per_unit), 2) AS revenue
    FROM category c
    JOIN products p USING (category_id)
    JOIN order_items oi USING (product_id)
    JOIN orders o USING (order_id)
    WHERE o.order_status <> 'Cancelled'
        AND o.order_date >= '2023-01-01'
        AND o.order_date < '2024-04-01'
    GROUP BY c.category_name, TO_CHAR(o.order_date, 'YYYY-"Q"Q')
    ORDER BY c.category_name, quarter 
    $$,
    $$ 
    SELECT DISTINCT TO_CHAR(order_date, 'YYYY-"Q"Q')
    FROM orders
    WHERE order_date >= '2023-01-01'
        AND order_date < '2024-04-01'
    ORDER BY 1 
    $$
) AS ct(
    category_name TEXT,
    "2023-Q1" NUMERIC,
    "2023-Q2" NUMERIC,
    "2023-Q3" NUMERIC,
    "2023-Q4" NUMERIC,
    "2024-Q1" NUMERIC
);
```

---

## 3. Revenue by Category

### Business Problem
Calculate total revenue generated by each product category and determine each category's percentage contribution to overall revenue.

### Expected Output
- Category name
- Percentage contribution to total revenue

### Solution

```sql
SELECT 
    category_name,
    ROUND(SUM(total_sale) / SUM(SUM(total_sale)) OVER () * 100, 2) AS contribution_pct
FROM order_items oi
JOIN products USING (product_id)
JOIN category USING (category_id)
GROUP BY category_name 
ORDER BY contribution_pct DESC;
```

---

## 4. Least-Selling Categories by State

### Business Problem
Identify the least-selling product category for each state to understand regional preferences and potentially adjust inventory or marketing strategies.

### Expected Output
- State
- Least-selling category
- Total sales for that category

### Solution

```sql
WITH cte AS (
    SELECT
        c.state,
        cat.category_name,
        SUM(oi.total_sale) AS total_sale,
        RANK() OVER (PARTITION BY c.state ORDER BY SUM(oi.total_sale) ASC) AS rnk
    FROM orders o
    JOIN customers c USING (customer_id)
    JOIN order_items oi USING (order_id)
    JOIN products p USING (product_id)
    JOIN category cat USING (category_id)
    GROUP BY c.state, cat.category_name
)
SELECT 
    state, 
    category_name, 
    total_sale
FROM cte
WHERE rnk = 1;
```

---

## 5. Product Returns Analysis

### Business Problem
The operations team has noticed that product returns are eating into profit margins. They need to identify which products have high return rates AND understand if returns are concentrated with specific sellers or shipping providers, enabling targeted action to reduce return losses.

### Objective
Identify products with return rates above 5% that have generated at least $10,000 in revenue. For each product, determine if returns are caused by seller quality issues (one seller has disproportionately high returns) or shipping problems (one provider has disproportionately high returns).

### Expected Output
- Product details and financial impact
- Overall return rate
- Total revenue and revenue lost to returns
- Primary cause (Seller-related or Shipping-related)
- Specific seller or shipping provider to investigate
- Recommended action

### Solution

```sql
WITH product_orders AS (
    SELECT
        p.product_id,
        p.product_name,
        c.category_name,
        o.order_id,
        o.seller_id,
        s_info.seller_name,
        sh.shipping_providers,
        sh.delivery_status,
        oi.price_per_unit * oi.quantity AS order_value,
        p.cogs * oi.quantity AS order_cost,
        (sh.delivery_status = 'Returned')::int AS is_returned
    FROM products p
    JOIN order_items oi USING (product_id)
    JOIN orders o USING (order_id)
    JOIN category c USING (category_id)
    LEFT JOIN sellers s_info USING (seller_id)
    LEFT JOIN shippings sh USING (order_id)
    WHERE o.order_status <> 'Cancelled'
),
product_metrics AS (
    SELECT
        product_id,
        product_name,
        category_name,
        COUNT(DISTINCT order_id) AS total_orders,
        SUM(is_returned) AS total_returns,
        SUM(order_value) AS total_revenue,
        SUM(order_value) FILTER (WHERE is_returned = 1) AS revenue_lost_to_returns,
        SUM(order_cost) FILTER (WHERE is_returned = 1) AS cost_of_returns,
        ROUND((SUM(is_returned)::DECIMAL / COUNT(DISTINCT order_id)) * 100, 2) AS return_rate_pct
    FROM product_orders
    GROUP BY
        product_id,
        product_name,
        category_name
),
seller_return_analysis AS (
    SELECT
        product_id,
        seller_id,
        seller_name,
        COUNT(DISTINCT order_id) AS seller_orders,
        SUM(is_returned) AS seller_returns,
        ROUND((SUM(is_returned)::DECIMAL / NULLIF(COUNT(DISTINCT order_id), 0)) * 100, 2) AS seller_return_rate,
        ROW_NUMBER() OVER (PARTITION BY product_id ORDER BY SUM(is_returned) DESC) AS seller_rank
    FROM product_orders
    GROUP BY
        product_id,
        seller_id,
        seller_name
    HAVING COUNT(DISTINCT order_id) >= 5
),
shipping_return_analysis AS (
    SELECT
        product_id,
        shipping_providers,
        COUNT(DISTINCT order_id) AS provider_orders,
        SUM(is_returned) AS provider_returns,
        ROUND((SUM(is_returned)::DECIMAL / NULLIF(COUNT(DISTINCT order_id), 0)) * 100, 2) AS provider_return_rate,
        ROW_NUMBER() OVER (PARTITION BY product_id ORDER BY SUM(is_returned) DESC) AS provider_rank
    FROM product_orders
    WHERE shipping_providers IS NOT NULL
    GROUP BY
        product_id,
        shipping_providers
    HAVING COUNT(DISTINCT order_id) >= 5
)
SELECT
    pm.product_id,
    pm.product_name,
    pm.category_name,
    pm.total_orders,
    pm.total_returns,
    pm.return_rate_pct,
    ROUND(pm.total_revenue, 2) AS total_revenue,
    ROUND(pm.revenue_lost_to_returns, 2) AS revenue_lost_to_returns,
    ROUND(pm.cost_of_returns, 2) AS cost_of_returns,
    ROUND(pm.revenue_lost_to_returns + pm.cost_of_returns, 2) AS total_return_impact,
    sra.seller_name AS top_return_seller,
    sra.seller_orders,
    sra.seller_returns,
    sra.seller_return_rate AS seller_return_rate_pct,
    sha.shipping_providers AS top_return_provider,
    sha.provider_orders,
    sha.provider_returns,
    sha.provider_return_rate AS provider_return_rate_pct,
    CASE
        WHEN sra.seller_return_rate > sha.provider_return_rate * 1.5 THEN 'Seller Quality Issue'
        WHEN sha.provider_return_rate > sra.seller_return_rate * 1.5 THEN 'Shipping/Handling Issue'
        ELSE 'Mixed Factors'
    END AS primary_return_cause,
    CASE
        WHEN sra.seller_return_rate > sha.provider_return_rate * 1.5
            THEN 'Review seller ' || sra.seller_name || ' - ' || sra.seller_return_rate || '% return rate'
        WHEN sha.provider_return_rate > sra.seller_return_rate * 1.5
            THEN 'Review shipping with ' || sha.shipping_providers || ' - ' || sha.provider_return_rate || '% return rate'
        ELSE 'Investigate product quality and packaging standards'
    END AS recommended_action
FROM product_metrics pm
LEFT JOIN seller_return_analysis sra
    ON pm.product_id = sra.product_id
    AND sra.seller_rank = 1
LEFT JOIN shipping_return_analysis sha
    ON pm.product_id = sha.product_id
    AND sha.provider_rank = 1
WHERE pm.return_rate_pct > 5
    AND pm.total_revenue > 10000
ORDER BY
    total_return_impact DESC;
```

### Adjustable Business Thresholds

- **Minimum Order Count (5)**: Filters out unreliable data from low-volume sellers/shippers. A seller with 2 orders and 1 return (50% rate) isn't as concerning as one with 100 orders and 50 returns. Adjust based on data size.

- **Significance Multiplier (1.5x)**: Determines when to attribute returns to seller vs. shipper. If seller has 20% returns but shipper has 35% returns (1.75x worse), shipping is flagged as the primary issue. Can be tuned between 1.3x-2x based on business requirements.

---

## 6. Revenue Decline Analysis

### Business Problem
Identify the top 10 products with the highest revenue decrease ratio when comparing 2022 vs 2023 to understand which products are losing market share or popularity.

### Expected Output
- Product name
- Category
- Revenue in 2022
- Revenue in 2023
- Revenue decrease ratio (percentage)

### Solution

```sql
WITH yearly_revenue AS (
    SELECT
        p.product_id,
        p.product_name,
        c.category_name,
        EXTRACT(YEAR FROM o.order_date) AS yr,
        SUM(oi.total_sale) AS revenue
    FROM orders o
    JOIN order_items oi USING (order_id)
    JOIN products p USING (product_id)
    JOIN category c USING (category_id)
    WHERE EXTRACT(YEAR FROM o.order_date) IN (2022, 2023)
    GROUP BY p.product_id, p.product_name, c.category_name, yr
),
ranked_products AS (
    SELECT
        curr.product_id,
        curr.product_name,
        curr.category_name,
        prev.revenue AS revenue_2022,
        curr.revenue AS revenue_2023,
        ROUND((curr.revenue - prev.revenue)::numeric / prev.revenue * 100, 2) AS revenue_decrease_ratio,
        RANK() OVER (ORDER BY (curr.revenue - prev.revenue) / prev.revenue) AS rnk
    FROM yearly_revenue curr
    JOIN yearly_revenue prev USING (product_id)
    WHERE prev.yr = 2022
        AND curr.yr = 2023
        AND curr.revenue < prev.revenue
)
SELECT
    product_name,
    category_name,
    revenue_2022,
    revenue_2023,
    revenue_decrease_ratio
FROM ranked_products
WHERE rnk <= 10;
```

---

## 7. Inactive Sellers Report

### Business Problem
Identify sellers who haven't made any sales in the last 6 months to evaluate seller performance and potentially remove inactive sellers from the platform.

### Expected Output
- Seller name
- Last sale date (or indication if no sales ever)
- Total historical sales

### Solution

```sql
WITH inactive_sellers AS (
    SELECT seller_id, seller_name
    FROM sellers s 
    WHERE NOT EXISTS (
        SELECT 1 
        FROM orders o 
        WHERE o.seller_id = s.seller_id 
            AND o.order_date >= CURRENT_DATE - INTERVAL '6 months'
    )
)
SELECT  
    ins.seller_name,
    COALESCE(MAX(o.order_date)::text, 'No sales ever') AS last_sale_date,
    COALESCE(SUM(oi.total_sale), 0) AS total_sales
FROM inactive_sellers ins
LEFT JOIN orders o ON o.seller_id = ins.seller_id
LEFT JOIN order_items oi ON oi.order_id = o.order_id
GROUP BY ins.seller_id, ins.seller_name
ORDER BY MAX(o.order_date) DESC NULLS LAST;
```

---

## 8. Inventory Optimization for High-Margin Products

### Business Problem
The operations team needs to identify which products are selling quickly AND generating healthy profit margins, but might be understocked. These products should be prioritized for inventory replenishment to avoid stockouts and maximize profitability.

### Objective
Find products where demand is high (sold 50+ units in last 6 months), profit margin is good (>40%), but current stock levels might be insufficient (less than 30 days of inventory based on recent sales velocity).

### Expected Output
- Product details
- Current stock level
- Sales velocity (units per day)
- Days of inventory remaining
- Profit margin
- Revenue generated
- Replenishment priority

### Solution

```sql
WITH recent_sales AS (
    SELECT
        p.product_id,
        p.product_name,
        c.category_name,
        p.price,
        p.cogs,
        ROUND(((p.price - p.cogs) / p.price) * 100, 2) AS profit_margin_pct,
        COUNT(DISTINCT o.order_id) AS num_orders,
        SUM(oi.quantity) AS units_sold_6months,
        SUM(oi.quantity * oi.price_per_unit) AS revenue_6months,
        COALESCE(i.stock, 0) AS current_stock
    FROM products p
    JOIN order_items oi USING (product_id)
    JOIN orders o USING (order_id)
    JOIN category c USING (category_id)
    LEFT JOIN inventory i USING (product_id)
    WHERE o.order_date >= CURRENT_DATE - INTERVAL '6 months'
        AND o.order_status <> 'Cancelled'
    GROUP BY
        p.product_id,
        p.product_name,
        c.category_name,
        p.price,
        p.cogs,
        i.stock
)
SELECT
    product_id,
    product_name,
    category_name,
    profit_margin_pct,
    units_sold_6months,
    ROUND(revenue_6months, 2) AS revenue_6months,
    current_stock,
    ROUND(units_sold_6months / 180.0, 2) AS daily_sales_velocity,
    ROUND(current_stock / NULLIF(units_sold_6months / 180.0, 0), 1) AS days_of_inventory_left,
    CASE
        WHEN current_stock / NULLIF(units_sold_6months / 180.0, 0) < 15 THEN 'URGENT - Restock Now'
        WHEN current_stock / NULLIF(units_sold_6months / 180.0, 0) BETWEEN 15 AND 30 THEN 'Restock Soon'
    END AS replenishment_priority
FROM recent_sales
WHERE units_sold_6months >= 50 -- High demand
    AND profit_margin_pct > 40  -- Good margins
    AND current_stock / NULLIF(units_sold_6months / 180.0, 0) < 30 -- Low stock
ORDER BY
    days_of_inventory_left ASC,
    revenue_6months DESC;
```

---

## 9. Underperforming Sellers Analysis

### Business Problem
The sales director needs to identify sellers who are generating low revenue despite having high order volumes. These sellers might be focusing on low-value products and need guidance to adjust their product mix toward more profitable items.

### Objective
Find sellers with at least 100 orders but an average order value below $300, then show them which high-value product categories (avg order value >$500) they should focus on to increase revenue.

### Expected Output
- Seller details (ID, name, origin)
- Current performance metrics (orders, revenue, avg order value)
- Performance gap compared to platform average
- Revenue opportunity
- Current best category
- Recommended high-value categories to focus on

### Solution

```sql
WITH seller_performance AS (
    SELECT
        s.seller_id,
        s.seller_name,
        s.origin,
        COUNT(DISTINCT o.order_id) AS total_orders,
        SUM(oi.total_sale) AS total_revenue,
        ROUND(AVG(oi.total_sale), 2) AS avg_order_value
    FROM sellers s
    JOIN orders o USING (seller_id)
    JOIN order_items oi USING (order_id)
    WHERE o.order_status <> 'Cancelled'
    GROUP BY
        s.seller_id,
        s.seller_name,
        s.origin
),
platform_avg AS (
    SELECT
        ROUND(AVG(oi.total_sale), 2) AS platform_avg_order_value
    FROM order_items oi
    JOIN orders o USING (order_id)
    WHERE o.order_status <> 'Cancelled'
),
high_value_categories AS (
    SELECT
        c.category_id,
        c.category_name,
        ROUND(AVG(oi.total_sale), 2) AS category_avg_order_value,
        COUNT(DISTINCT oi.order_id) AS category_total_orders
    FROM category c
    JOIN products p USING (category_id)
    JOIN order_items oi USING (product_id)
    JOIN orders o USING (order_id)
    WHERE o.order_status <> 'Cancelled'
    GROUP BY
        c.category_id,
        c.category_name
    HAVING AVG(oi.total_sale) > 500 -- Only high-value categories
),
seller_category_performance AS (
    SELECT
        s.seller_id,
        c.category_name,
        SUM(oi.total_sale) AS category_revenue,
        ROW_NUMBER() OVER (
            PARTITION BY s.seller_id
            ORDER BY SUM(oi.total_sale) DESC
        ) AS category_rank
    FROM sellers s
    JOIN orders o USING (seller_id)
    JOIN order_items oi USING (order_id)
    JOIN products p USING (product_id)
    JOIN category c USING (category_id)
    WHERE o.order_status <> 'Cancelled'
    GROUP BY
        s.seller_id,
        c.category_name
)
SELECT
    sp.seller_id,
    sp.seller_name,
    sp.origin,
    sp.total_orders,
    ROUND(sp.total_revenue, 2) AS current_revenue,
    sp.avg_order_value AS current_avg_order_value,
    pa.platform_avg_order_value,
    ROUND(sp.avg_order_value - pa.platform_avg_order_value, 2) AS performance_gap,
    ROUND((pa.platform_avg_order_value - sp.avg_order_value) * sp.total_orders, 2) AS revenue_opportunity,
    scp.category_name AS current_best_category,
    ROUND(scp.category_revenue, 2) AS best_category_revenue,
    STRING_AGG(
        hvc.category_name,
        ', '
        ORDER BY hvc.category_avg_order_value DESC
    ) AS recommended_high_value_categories
FROM seller_performance sp
CROSS JOIN platform_avg pa
LEFT JOIN seller_category_performance scp
    ON sp.seller_id = scp.seller_id
    AND scp.category_rank = 1
LEFT JOIN high_value_categories hvc
    ON 1 = 1
WHERE sp.total_orders >= 100 -- Exclude low-volume sellers
    AND sp.avg_order_value < 300 -- Filter for underperforming sellers
GROUP BY
    sp.seller_id,
    sp.seller_name,
    sp.origin,
    sp.total_orders,
    sp.total_revenue,
    sp.avg_order_value,
    pa.platform_avg_order_value,
    scp.category_name,
    scp.category_revenue
ORDER BY
    revenue_opportunity DESC;
```

---

## 10. Monthly Seller Performance Report Function

### Business Problem
The sales management team needs a standardized monthly report to evaluate seller performance, identify top revenue generators, and understand which product categories are driving sales for each seller. This data is critical for making informed decisions about seller partnerships, commission adjustments, and strategic planning.

### Objective
Create a reusable function that generates a comprehensive monthly sales report for any given month and year. The report should rank all active sellers by revenue, calculate key performance metrics, and identify each seller's top-performing category. Cancelled orders must be excluded to ensure accuracy.

### Expected Output
- Report period (Month YYYY format)
- Seller rank (by revenue)
- Seller identification (ID, name, origin)
- Total orders completed
- Total revenue generated
- Average order value
- Top product category by revenue
- All results ordered by revenue performance (highest to lowest)

### Solution

```sql
CREATE OR REPLACE FUNCTION get_monthly_sales_report(
    p_month INTEGER,
    p_year INTEGER
)
RETURNS TABLE (
    report_period TEXT, 
    rank INTEGER,
    seller_id INTEGER,
    seller_name VARCHAR,
    origin VARCHAR,
    total_orders BIGINT,
    total_revenue NUMERIC,
    avg_order_value NUMERIC,
    top_category VARCHAR
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := make_date(p_year, p_month, 1);
    v_end_date := (v_start_date + INTERVAL '1 month')::DATE;
    
    RETURN QUERY
    WITH seller_revenue AS (
        SELECT 
            s.seller_id,
            s.seller_name,
            s.origin,
            COUNT(DISTINCT o.order_id) AS total_orders,
            ROUND(SUM(oi.quantity * oi.price_per_unit), 2) AS total_revenue,
            ROUND(AVG(oi.quantity * oi.price_per_unit), 2) AS avg_order_value
        FROM sellers s
        JOIN orders o ON s.seller_id = o.seller_id
        JOIN order_items oi ON o.order_id = oi.order_id
        WHERE o.order_date >= v_start_date
            AND o.order_date < v_end_date
            AND o.order_status <> 'Cancelled'
        GROUP BY s.seller_id, s.seller_name, s.origin
    ),
    category_revenue AS (
        SELECT 
            o.seller_id,
            c.category_name,
            SUM(oi.quantity * oi.price_per_unit) AS category_revenue,
            ROW_NUMBER() OVER (
                PARTITION BY o.seller_id 
                ORDER BY SUM(oi.quantity * oi.price_per_unit) DESC
            ) AS category_rank
        FROM orders o
        JOIN order_items oi ON o.order_id = oi.order_id
        JOIN products p ON oi.product_id = p.product_id
        JOIN category c ON p.category_id = c.category_id
        WHERE o.order_date >= v_start_date
            AND o.order_date < v_end_date
            AND o.order_status <> 'Cancelled'
        GROUP BY o.seller_id, c.category_name
    )
    SELECT
        TO_CHAR(v_start_date, 'Month YYYY') AS report_period, 
        ROW_NUMBER() OVER (ORDER BY sr.total_revenue DESC)::INTEGER AS rank,
        sr.seller_id,
        sr.seller_name,
        sr.origin,
        sr.total_orders,
        sr.total_revenue,
        sr.avg_order_value,
        cr.category_name AS top_category
    FROM seller_revenue sr
    LEFT JOIN category_revenue cr 
        ON sr.seller_id = cr.seller_id 
        AND cr.category_rank = 1
    ORDER BY sr.total_revenue DESC;
END;
$$;
```

### Usage Examples

```sql
-- Get report for January 2024
SELECT * FROM get_monthly_sales_report(1, 2024);

-- Get report for December 2023
SELECT * FROM get_monthly_sales_report(12, 2023);

-- Get report for current month
SELECT * FROM get_monthly_sales_report(
    EXTRACT(MONTH FROM CURRENT_DATE)::INTEGER, 
    EXTRACT(YEAR FROM CURRENT_DATE)::INTEGER
);
```
